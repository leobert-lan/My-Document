---
title： Android develop specifications
---

# Android develop specifications #
author：leobert.lan</br>
time： 6/29/2016 1:17:04 PM 

## 代码管理 ##
代码统一使用git管理，远端部署在公司服务器上。

### 工作流 ###
- master分支掌控几乎所有的变更。
	- **master分支作为开发分支**，鉴于Android项目相对web端更加紧凑，在既定的某版本规划内，可以做到在一个分支上进行管理。
	- **跨版本情况**，该情况会影响在一条分支上协同工作，一般而言移动端出现跨版本同时开发的情况较为少见，以开辟新分支的方式为主。具体情况由项目管理人员具体分析决定。
- 抽象的test分支
	- 每一个既定版本进入测试阶段时，创建与版本名相关的测试分支
	- 所有的测试环节代码改动在测试分支完成，最终同步到master分支
	- 管理见分支管理小节#测试分支
- 非高频高次迭代项目不建立发布分支

### 分支管理 ###

#### 开发分支 ####
- 每日开始工作时打tag
- 每日结束工作时打tag
- 开发阶段每日保持代码同步
#### 测试分支 ####
- 每个版本都有对应的测试分支，local&remote
- 测试分支保留至少一个版本，以备出现紧急线上bug
#### 发布分支 ####
- Android 开发组给到测试组正式的apk，承担打包编译。
- 非预定高频高次迭代计划的项目不适用发布分支

### 内容管理 ###
包含但不限于以下内容：

- code
- doc
- design-prototype
- uiRes
- keys
- release

code存储项目代码

doc存储文档，主要收录重要的设计，例如数据库设计文档、web-api文档、项目架构设计文档，（需求文档，功能设计文档如存在亦收录）和重要的信息（例如友盟统计注册的app信息等）。

design-prototype存储每个版本的设计原型

uiRes备份ui交付的切图资源和设计稿

keys保存调试、发布所使用的签名密钥

release保存历史安装包，按照版本划分，注意备份release-note

### 提交&同步 ###
每一个功能、甚至一段你觉得有意义的代码写完后立即提交到本地，log详见branchName&log&tag

自测完成一个功能后，完整的规范的填写log，提交到本地并同步远端。

永远记得提交远端之前的两件事情：**拉取远端代码，解决冲突**

### branchName&log&tag ###

#### branchName： ####

[type]\_[version]\_[retain]

retain作为保留字段，特殊情况下便于区分



> e.g.：</br>
> test_v1.1.0 </br>1.1.0版本测试分支

#### log: ####

如果在一个功能的开发过程中，仅仅是保存一段代码（往往好几个文件都有改动，不提交代码，半小时内来会改几次都会很乱，如果代码设计有问题很难下决心回滚），提交的log直接用“save”



> 做较为关键的提交时，按照三段式：
> </br>
> 第一段：主题
> </br>
> 第二段：描述
> </br>
> 第三段：个人信息

一般第三段可以由工具直接追加，所以也有三行式的说法，因为第一段和第二段之间有一个空行。**注意这个主要是给人看的，规范一点，能表达清楚这次干了啥就行,不要写太长**

**主题：**

[type] + link + brief description

主要type 如下：

- Add ( 新加入的需求 我们约定表示开始做这个需求)
- Fix ( 修复 bug )
- complete ( 完成的任务 )
- Update ( 完成的升级任务，或者由于第三方模块变化而做的变化 )

link可以只放redmine上的任务号，但建议在整个commit log中包含任务完整链接

brief description是简单的描述

**描述：**

具体的描述，redmine具体的链接，修改了哪些文件等等。

#### Tag: ####
tag是为了标记一些重要的点，milestones一定是需要用tag标记的。

不强求日常标记也填写详细的日志，因为有redmine系统。

表示里程碑的tag一定要列出重点。

> 命名格式：[type]\_desc\_[retain]

type：

- dtag 日常标记
- ttag 测试相关
- TAG 标识版本里程碑

e.g.：

> dtag\_2016-06-28\_start *某日开始工作的标记点*

<p>

> dtag\_2016-06-28\_end *某日结束工作的标记点*

<p>

> ttag\_v1.1.0\_end *测试工作全部结束的tag*

<p>

> TAG\_v1.1.0 *v1.1.0版本工作完成*

额外说明：

里程碑式的tag的log 
第一行：milestone+version+desc

ttag，开始测试的tag内容写主要的测试功能和redmine 测试任务链接。测试通过时主要写修改的bug（如果有）或测试通过。

TAG，版本工作全部完成再创建，该备份的包备份，该有的文档要有。描述主要和release-note挂钩

## 代码规范 ##

这里主要罗列重要点，更多内容请移步[Google Java编程风格指南](http://www.hawstein.com/posts/google-java-style.html)

### hardcode ###

不要打算在代码中保留hardcode，有些时候我们确实需要紧急的写上一些带有异味的代码，但至少保留基本道德素养：

> 在上一行注释 //TODO： hardcode

这样结合IDE还能较为方便地找到。

对于资源暂未到位的情况，某些情况下字符串资源没有到位，在字符串资源中定义一个资源，表示资源暂未给。

但凡可复用的，都定义成资源

**临时的dummy数据，一定一定要在自己测试逻辑后改成真实数据**

更好一点的做法是定义dummydata类，有了统一的管理还是有快捷的方法找到代码中的异味的。

### 命名规范 ###

- 类、接口等命名使用大驼峰法
- 成名命名使用小驼峰法
- 逻辑中的局部变量可以使用匈牙利法或者简单的命名（不要写太长的逻辑段，尽量拆分）

类命名需要直击要点，设计模式相关的按照既有风格即可，例如工厂那就尾部追加Factory，适配器就尾部追加Adapter

一般抽象类头部为Abs

接口类以 I 开头，主体按照功能获得命名。

- 表示监听器功能尾部追加Listener。
- 普通的回调尾部追加Callback。
	- 往往使用Callback暗示着回调发起者没有后续的逻辑了。
- 在异步过程、特定的功能组中，亦可使用Handler追加于尾部命名回调接口。
	- 一般涉及主线程敏感操作时（或者衍生到跨线程）才使用，以避免误解。

一般而言，实现类尾部追加Impl，基础默认实现类以Default开头，往往是个空实现。

命名需要一定的功底，除了一些约定俗成的规定外，积累一些常用的、合适的英文单词是很有必要的。避免使用生僻词、产生误解的词。

**名字从散文形式(prose form)开始:**



> 把短语转换为纯ASCII码，并且移除任何单引号。

例如：”Müller’s algorithm”将变成”Muellers algorithm”。



1. **把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。**</br>
推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。
2. **现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写**：
	- 每个单词的第一个字母都大写，来得到大驼峰式命名。
	- 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。
3. 最后将所有的单词连接起来得到一个标识符。


示例：
>Prose form:  "XML HTTP request"

**Corrent:** XmlHttpRequest</br>
**Incorrect:** XMLHTTPRequest
            
>Prose form:  "new customer ID" 

**Corrent:** newCustomerId</br>
**Incorrect:** newCustomerID

>Prose form:  "inner stopwatch" 

**Corrent:** innerStopwatch</br>
**Incorrect:** innerStopWatch

>Prose form:  "supports IPv6 on iOS?" 

**Corrent:** supportsIpv6OnIos</br>
**Incorrect:** supportsIPv6OnIOS

>Prose form:  "YouTube importer" 

**Corrent:** YouTubeImporter YoutubeImporter*

加星号处表示可以，但不推荐。

Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。

### 编码&特殊字符 ###
源文件使用UTF-8，这是常识。

#### 特殊字符 ####

- 除了行结束符序列，**ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符**，所有其它字符串中的空白字符都要进行转义。

- **缩进使用空格，不要使用制表符**。不要形而上，IDE几乎都支持设置tab是否替换为多个space进行输入。


- 对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, ", '及\)，**使用它的转义序列**，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。

- 对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。

- 额外补充上一条：如果是用于显示的，定义在string资源中，并按照xml文件的规则进行转义

> Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。


例如：

> - String unitAbbrev = "μs";</br>
> 赞，即使没有注释也非常清晰
> <p>
> - String unitAbbrev = "\u03bcs"; // "μs"</br>
> 允许，但没有理由要这样做
> <p>
> - String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"
> <p>
> 允许，但这样做显得笨拙还容易出错
> <p>
> - String unitAbbrev = "\u03bcs";
> <p>
> 很糟，读者根本看不出这是什么
> <p>
> - return '\ufeff' + content; // byte order mark
> <p>
> Good，对于非打印字符，使用转义，并在必要时写上注释

<p>


> Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)

### 代码风格 ###

#### 大括号 ####
使用大括号(即使是可选的)
大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。

#### 非空块：K&R风格 ####

- 左大括号前不换行
- 左大括号后换行
- 右大括号前换行
- 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。

#### 注释 ####
任何让人需要思考两下的东西都需要写注释

注释是一件很恼人的事情，写在尾部还是写在前面有不同的约定，甚至版本信息，修改信息都可以放在注释中，但注意：**代码的可读性是最重要的，不要让注释影响代码的可读性**

关于写在头部还是写在尾部，写在尾部代表行注释，但这样会带来很多问题：

- IDE格式化代码时破坏了你的空格
- 添加了一段较长的代码而不得不整理所有的排版
- 突破列限制
- 合并代码无数的冲突

> 我认为：代码的可读性取决于代码本身，注释只是辅助

所以写在头部好了，使用空行可以暗示代码行之间的组织关系。

//comment  </br> 
code1

code2

这样可以很轻易的看出注释的对象，

对于非空块，我们约定在注释后加空行代表对块的注释。

对于成员变量，如果你真的觉得它很难被记住，首先你要考虑命名是不是不合适，然后使用javadoc的方式，这样就不必跳回到定义的地方。

**关于代码跨版本修改过bug是否需要额外注释：**
除非是非常非常重要的，有可能关联到还在开发的模块，或者此模块还有升级的可能的。**否则都不要写**

reasons：

- 基本不会回滚到以前的版本
- 回滚到历史版本也不会先看一遍所有的注释来发现重要事件
- 接盘的人也不会在意你以前版本中出现、现在已经被解决的bug，即使有标记也不会找历史代码看原来的bug
- **影响当今健康的代码的阅读**

### 包管理 ###
基础框架中已经进行了分包，注意包路径中不要出现大写，词组直接连缀。

### 列限制 ###
80或100

### 常量 ###
只有真正的常量才适合定义成常量，如果观测状态是可变的，尽量不要使用final修饰，也许会产生不必要的误解。

真正的常量使用CONSTANT_CASE命名模式，如果是全局的静态常量，可以在尝试在接口中定义。

### 注解 ###
该使用就使用，自定义的注解不在本篇中进行约定。
@Override但凡合法就不要漏掉
@Deprecate用来注解一些抛弃的功能、类还是很有必要的，并附加相关注释。并在新的替代物稳定可用后删除弃用内容

### javadoc ###
不求有多美观，至少按照现有的来执行。至少阅读代码的时候可读性增强了。

### 成员函数 ###
命名参照命名规范部分，使用lowerCamelCase。

自定义的函数都需要javadoc

适当调整排序，不要新增的总是在尾部，重载一定要成组，一般“最根本”的重载方法写在组的结尾。

私有方法一般紧跟调用，但这个没有可靠的、严格的规定

### 逻辑段 ###
如果你的逻辑段超过一屏，想想你是不是应该把某些代码块迁移到一个函数内部。

如果你的判断句很长，想想是不是可以定义成方法，至少一个函数名表达的含义要比实际逻辑表达式容易理解。

### 三目运算符 ###

**除非这段代码让所有人都觉得用if-else来写很蠢**，否则不要使用三目运算符。

### 位运算 ###
某些情况下不妨尝试枚举，除非你写的是一个底层核心模块，使用了Interpret模式，或者其他更合适的方式封装，并且不打算让除了你以外的人类阅读。





